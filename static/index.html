<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>木板飞船 Demo</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      background: #000;
      width: 100vw;
      height: 100vh;
    }
    #info {
      position: fixed;
      left: 10px;
      top: 10px;
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px 8px;
      border-radius: 4px;
      z-index: 10;
      white-space: pre-line;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="info">
    控制：
      ← / → 整体旋转，Space 点火
      Shift：姿态稳定（锁定当前朝向）
      鼠标滚轮：缩放视角

    建造：
      B：切换“木板建造模式”
         - 拖拽：从【节点或引擎】拖 → 松开连到【节点/引擎】 / 空中 = 木板 + 新节点
         - 删除：建造模式下【单击选中】节点/引擎/木板（优先级：节点 > 引擎 > 木板），按 Delete/Backspace 删除
      按住 1 + 左键拖：从【高亮节点】拉出引擎（长度越长，引擎越大）

    自由视角：
      Tab：切换自由相机（开启后 WASD 移动相机）
      轨迹预测：从后端 /api/predict 拉取（真实模拟）
        - 默认 ballistic（惯性预测）
        - 按住 Space 时用 current（把持续点火/转向当作未来输入）
  </div>

  <canvas id="gameCanvas"></canvas>

  <script>
    // ------------------------------
    // 多人：我的身份
    // ------------------------------
    let myUid = null;
    let myShipId = null;
    let joined = false;
    let mouseScreenPos = { x: 0, y: 0 };
    let lastStateArrivedAt = performance.now() / 1000;

    async function joinGame() {
      const res = await fetch("/api/join", { method: "POST" });
      const data = await res.json();
      if (!data.ok) throw new Error(data.error || "join failed");
      myUid = data.uid;
      myShipId = data.ship_id;
      joined = true;
    }

    function getMyShip() {
      if (!worldState.ships) return null;
      return worldState.ships.find(s => s.id === myShipId) || null;
    }

    // ------------------------------
    // 速度估计（基于我的核心）
    // ------------------------------
    let coreVelEst = { vx: 0, vy: 0 };
    let lastCoreSample = null;

    function updateCoreVelocityEstimate() {
      const ship = getMyShip();
      const core = ship?.nodes?.[0];
      if (!core) return;

      const now = performance.now() / 1000;
      if (!lastCoreSample) {
        lastCoreSample = { x: core.x, y: core.y, t: now };
        return;
      }
      const dt = now - lastCoreSample.t;
      if (dt <= 1e-4) return;

      const vx = (core.x - lastCoreSample.x) / dt;
      const vy = (core.y - lastCoreSample.y) / dt;

      const k = 0.25;
      coreVelEst.vx = coreVelEst.vx * (1 - k) + vx * k;
      coreVelEst.vy = coreVelEst.vy * (1 - k) + vy * k;

      lastCoreSample = { x: core.x, y: core.y, t: now };
    }

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let W = 0, H = 0, CX = 0, CY = 0;
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      W = canvas.width;
      H = canvas.height;
      CX = W / 2;
      CY = H / 2;
    }
    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function getPrimaryPlanet() {
      return worldState.planets?.[0] ?? null;
    }
    function getCorePos() {
      const ship = getMyShip();
      const core = ship?.nodes?.[0];
      if (!core) return null;
      return { x: core.x, y: core.y };
    }

    function computeDesiredPredictSeconds() {
      const p = getPrimaryPlanet();
      const c = getCorePos();
      if (!p || !c) return 25;

      const dx = c.x - p.x;
      const dy = c.y - p.y;
      const r = Math.hypot(dx, dy);

      const speed = Math.max(1.0, Math.hypot(coreVelEst.vx, coreVelEst.vy));

      const T_orbit = 2 * Math.PI * r / speed;
      const worldSpan = Math.max(W, H) / cameraZoom;
      const Nscreens = 6;
      const T_view = (Nscreens * worldSpan) / speed;

      const zoomFactor = clamp(1 / cameraZoom, 0.5, 6.0);

      let seconds = Math.max(T_view, T_orbit) * zoomFactor;
      seconds = clamp(seconds, 10, 600);
      return seconds;
    }

    function chooseDtAndStride(seconds) {
      let dt = 1/60;
      if (seconds > 60)  dt = 1/30;
      if (seconds > 180) dt = 1/15;
      if (seconds > 420) dt = 1/10;

      const steps = seconds / dt;
      const targetPts = 1200;
      const stride = Math.max(1, Math.ceil(steps / targetPts));
      return { dt, stride };
    }

    function choosePredictCooldownMs(seconds) {
      if (seconds > 180) return 1200;
      if (seconds > 60)  return 700;
      return 250;
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // 摄像机缩放
    let cameraZoom = 1.0;
    const MIN_ZOOM = 0.002;
    const MAX_ZOOM = 100.0;

    const keys = {};
    let worldState = { planets: [], ships: [] };

    // 相机：跟随 / 自由
    let freeCamera = false;
    let freeCamPos = { x: 0, y: 0 };
    const CAM_SPEED = 900;

    function getFollowCenter(nowSec) {
      let camX = 0, camY = 0;
      const ship = worldState.ships?.[0];
      const core = ship?.nodes?.[0];
      if (core) {
        const p = predictPose(core, nowSec);
        camX = p.x;
        camY = p.y;
      }
      return { x: camX, y: camY };
    }

    function getCameraCenter(nowSec) {
      return freeCamera ? freeCamPos : getFollowCenter(nowSec);
    }

    function applyCameraTransform(nowSec) {
      const cam = getCameraCenter(nowSec);

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, W, H);

      ctx.translate(CX, CY);
      ctx.scale(cameraZoom, -cameraZoom);
      ctx.translate(-cam.x, -cam.y);
    }

    function screenToWorld(sx, sy) {
      const nowSec = performance.now() / 1000;
      const cam = getCameraCenter(nowSec);
      const wx = (sx - CX) / cameraZoom + cam.x;
      const wy = -(sy - CY) / cameraZoom + cam.y;
      return { x: wx, y: wy };
    }

    function updateFreeCamera(dt) {
      if (!freeCamera) return;
      const v = (CAM_SPEED / cameraZoom) * dt;
      if (keys["KeyW"]) freeCamPos.y += v;
      if (keys["KeyS"]) freeCamPos.y -= v;
      if (keys["KeyA"]) freeCamPos.x -= v;
      if (keys["KeyD"]) freeCamPos.x += v;
    }

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      if (e.deltaY < 0) cameraZoom = Math.min(MAX_ZOOM, cameraZoom * zoomFactor);
      else cameraZoom = Math.max(MIN_ZOOM, cameraZoom / zoomFactor);
    }, { passive: false });

    // ------------------------------
    // 建造 / 删除（只作用我的船）
    // ------------------------------
    let buildMode = false;

    let hoverAnchor = null;        // { kind:"node"|"engine", index }
    let hoverDeleteTarget = null;  // { kind:"node"|"engine"|"plank", index }
    let selectedTarget = null;     // { kind:"node"|"engine"|"plank", index }

    let dragWorldPos = { x: 0, y: 0 };

    let isDraggingPlank = false;
    let plankStartAnchor = null;

    let isDraggingEngine = false;
    let engineStartNode = null; // {kind:"node", index}

    let mouseDown = false;
    let mouseDownScreen = { x: 0, y: 0 };
    let pendingPlankStartAnchor = null;
    const CLICK_DRAG_THRESHOLD_PX = 6;
    const HOVER_PIXEL_RADIUS = 25;

    function distPointToSegment(px, py, ax, ay, bx, by) {
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      const ab2 = abx * abx + aby * aby;
      if (ab2 < 1e-12) return Math.hypot(px - ax, py - ay);
      let t = (apx * abx + apy * aby) / ab2;
      t = Math.max(0, Math.min(1, t));
      const cx = ax + t * abx;
      const cy = ay + t * aby;
      return Math.hypot(px - cx, py - cy);
    }

    function findBestAnchorAtWorld(world) {
      const ship = getMyShip();
      if (!ship) return null;

      const thresholdWorld = HOVER_PIXEL_RADIUS / cameraZoom;
      let best = null;
      let bestDist = Infinity;

      (ship.nodes || []).forEach((node, ni) => {
        const d = Math.hypot(node.x - world.x, node.y - world.y);
        if (d < bestDist && d < thresholdWorld) {
          bestDist = d;
          best = { kind: "node", index: ni };
        }
      });

      (ship.engines || []).forEach((eng, ei) => {
        const d = Math.hypot(eng.x - world.x, eng.y - world.y);
        if (d < bestDist && d < thresholdWorld) {
          bestDist = d;
          best = { kind: "engine", index: ei };
        }
      });

      return best;
    }

    function findBestDeleteTargetAtWorld(world) {
      const ship = getMyShip();
      if (!ship) return null;

      const thresholdNodeWorld = HOVER_PIXEL_RADIUS / cameraZoom;

      // node
      let bestNode = null;
      let bestNodeDist = Infinity;
      (ship.nodes || []).forEach((node, ni) => {
        const d = Math.hypot(node.x - world.x, node.y - world.y);
        if (d < bestNodeDist && d < thresholdNodeWorld) {
          bestNodeDist = d;
          bestNode = { kind: "node", index: ni };
        }
      });
      if (bestNode) return bestNode;

      // engine
      let bestEng = null;
      let bestEngDist = Infinity;
      (ship.engines || []).forEach((eng, ei) => {
        const d = Math.hypot(eng.x - world.x, eng.y - world.y);
        const thresholdEngWorld = Math.max(thresholdNodeWorld, eng.radius * 1.8);
        if (d < bestEngDist && d < thresholdEngWorld) {
          bestEngDist = d;
          bestEng = { kind: "engine", index: ei };
        }
      });
      if (bestEng) return bestEng;

      // plank
      let bestPlank = null;
      let bestPlankDist = Infinity;
      (ship.planks || []).forEach((pl, pi) => {
        const hx = Math.cos(pl.angle) * (pl.length / 2);
        const hy = Math.sin(pl.angle) * (pl.length / 2);
        const ax = pl.x - hx, ay = pl.y - hy;
        const bx = pl.x + hx, by = pl.y + hy;

        const d = distPointToSegment(world.x, world.y, ax, ay, bx, by);
        const thickness = (pl.radius * 2);
        const extra = (HOVER_PIXEL_RADIUS / cameraZoom) * 0.6;
        const thresholdPlankWorld = thickness + extra;

        if (d < bestPlankDist && d < thresholdPlankWorld) {
          bestPlankDist = d;
          bestPlank = { kind: "plank", index: pi };
        }
      });

      return bestPlank;
    }

    function getAnchorWorldPos(anchor) {
      const ship = getMyShip();
      if (!ship) return null;
      if (anchor.kind === "node") return ship.nodes?.[anchor.index] ?? null;
      return ship.engines?.[anchor.index] ?? null;
    }
    function updateMouseWorldAndHoverPerFrame() {
      // 用“此刻相机中心”把鼠标屏幕坐标转回世界坐标
      const world = screenToWorld(mouseScreenPos.x, mouseScreenPos.y);
      dragWorldPos = world;

      const building = buildMode || !!keys["Digit1"];
      hoverAnchor = building ? findBestAnchorAtWorld(world) : null;
      hoverDeleteTarget = buildMode ? findBestDeleteTargetAtWorld(world) : null;

      // 拖拽阈值判定也最好放这里（相机动时也能触发）
      if (buildMode && mouseDown && pendingPlankStartAnchor && !isDraggingPlank && !keys["Digit1"]) {
        const dx = mouseScreenPos.x - mouseDownScreen.x;
        const dy = mouseScreenPos.y - mouseDownScreen.y;
        if (Math.hypot(dx, dy) > CLICK_DRAG_THRESHOLD_PX) {
          isDraggingPlank = true;
          plankStartAnchor = pendingPlankStartAnchor;
          pendingPlankStartAnchor = null;
        }
      }
    }

    // ------------------------------
    // 轨迹预测（只预测我的船）
    // ------------------------------
    let predictedPoints = [];
    let predictedMeta = null;
    let isPredicting = false;
    let lastPredictAt = 0;

    async function fetchPredict() {
      if (!joined) return;
      if (isPredicting) return;

      const ship = getMyShip();
      if (!ship) return;

      const seconds = computeDesiredPredictSeconds();
      const { dt, stride } = chooseDtAndStride(seconds);
      const cooldown = choosePredictCooldownMs(seconds);

      const now = performance.now();
      if (now - lastPredictAt < cooldown) return;
      lastPredictAt = now;

      const mode = "ballistic";

      isPredicting = true;
      try {
        const res = await fetch("/api/predict", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ uid: myUid, ship_id: myShipId, seconds, dt, stride, mode }),
        });
        if (!res.ok) return;

        const data = await res.json();
        if (data.ok) {
          predictedPoints = data.points || [];
          predictedMeta = data;
        }
      } catch (e) {
      } finally {
        isPredicting = false;
      }
    }

    function drawPredictedTrajectory() {
      if (!predictedPoints || predictedPoints.length < 2) return;

      ctx.save();
      ctx.lineWidth = 1.2 / cameraZoom;
      ctx.strokeStyle = "#0f0";

      const n = predictedPoints.length;
      const seg = 6;
      for (let i = 0; i < n - 1; i += seg) {
        const jEnd = Math.min(n - 1, i + seg);
        const t = i / (n - 1);
        const alpha = 0.75 * (1.0 - t) + 0.10;
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.moveTo(predictedPoints[i].x, predictedPoints[i].y);
        for (let j = i + 1; j <= jEnd; j++) ctx.lineTo(predictedPoints[j].x, predictedPoints[j].y);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.fillStyle = "#0f0";
      const step = 25;
      for (let i = step; i < n; i += step) {
        const t = i / (n - 1);
        ctx.globalAlpha = 0.45 * (1.0 - t) + 0.08;
        const pt = predictedPoints[i];
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 1.8 / cameraZoom, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    // ------------------------------
    // 键盘事件
    // ------------------------------
    window.addEventListener("keydown", (e) => {
      keys[e.code] = true;

      if (e.code === "Tab") {
        e.preventDefault();
        freeCamera = !freeCamera;
        if (freeCamera) {
          const c = getFollowCenter();
          freeCamPos.x = c.x;
          freeCamPos.y = c.y;
        }
        return;
      }

      if (e.code === "KeyB") {
        buildMode = !buildMode;
        hoverDeleteTarget = null;
        if (!buildMode) selectedTarget = null;
      }

      if ((e.code === "Delete" || e.code === "Backspace") && buildMode) {
        if (selectedTarget && joined) {
          e.preventDefault();
          fetch("/api/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              uid: myUid,
              ship_id: myShipId,
              target: { type: selectedTarget.kind, index: selectedTarget.index },
            }),
          })
            .then((res) => res.json())
            .then((data) => {
              if (!data.ok) console.error("删除失败", data.error);
              else selectedTarget = null;
            })
            .catch((err) => console.error("删除请求错误", err));
        }
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.code] = false;
    });

    // ------------------------------
    // 鼠标事件
    // ------------------------------
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      mouseScreenPos = { x: mx, y: my };

      const building = buildMode || !!keys["Digit1"];
      hoverAnchor = building ? findBestAnchorAtWorld(world) : null;
      hoverDeleteTarget = buildMode ? findBestDeleteTargetAtWorld(world) : null;

      if (buildMode && mouseDown && pendingPlankStartAnchor && !isDraggingPlank && !keys["Digit1"]) {
        const dx = mx - mouseDownScreen.x;
        const dy = my - mouseDownScreen.y;
        if (Math.hypot(dx, dy) > CLICK_DRAG_THRESHOLD_PX) {
          isDraggingPlank = true;
          plankStartAnchor = pendingPlankStartAnchor;
          pendingPlankStartAnchor = null;
        }
      }
    });

    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      mouseDown = true;
      mouseDownScreen = { x: mx, y: my };

      if (keys["Digit1"]) {
        if (hoverAnchor && hoverAnchor.kind === "node") {
          isDraggingEngine = true;
          engineStartNode = hoverAnchor;
        }
        return;
      }

      if (buildMode) {
        pendingPlankStartAnchor = hoverAnchor;
      }
    });

    canvas.addEventListener("mouseup", (e) => {
      if (e.button !== 0) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const world = screenToWorld(mx, my);

      // 引擎建造
      if (isDraggingEngine && engineStartNode && joined) {
        fetch("/api/build_engine", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            uid: myUid,
            ship_id: myShipId,
            from_node: engineStartNode.index,
            target: { x: world.x, y: world.y },
          }),
        })
          .then((res) => res.json())
          .then((data) => { if (!data.ok) console.error("建造引擎失败", data.error); })
          .catch((err) => console.error("建造引擎请求错误", err));
      }

      // 木板建造
      if (isDraggingPlank && plankStartAnchor && joined) {
        const best = findBestAnchorAtWorld(world);
        let payload = null;

        if (!best) {
          payload = {
            uid: myUid,
            ship_id: myShipId,
            from: { type: plankStartAnchor.kind, index: plankStartAnchor.index },
            to_node: -1,
            new_node_pos: { x: world.x, y: world.y },
          };
        } else {
          if (!(plankStartAnchor.kind === best.kind && plankStartAnchor.index === best.index)) {
            payload = {
              uid: myUid,
              ship_id: myShipId,
              from: { type: plankStartAnchor.kind, index: plankStartAnchor.index },
              to:   { type: best.kind, index: best.index },
            };
          }
        }

        if (payload) {
          fetch("/api/build_plank", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          })
            .then((res) => res.json())
            .then((data) => { if (!data.ok) console.error("建造木板失败", data.error); })
            .catch((err) => console.error("建造木板请求错误", err));
        }
      }

      // 点击选中删除目标
      if (buildMode && !keys["Digit1"] && !isDraggingPlank && !isDraggingEngine) {
        selectedTarget = findBestDeleteTargetAtWorld(world);
      }

      mouseDown = false;
      pendingPlankStartAnchor = null;

      isDraggingEngine = false;
      engineStartNode = null;

      isDraggingPlank = false;
      plankStartAnchor = null;
    });

    // ------------------------------
    // 绘制
    // ------------------------------
    function drawWorld() {
      const nowSec = performance.now() / 1000;
      applyCameraTransform(nowSec);

      drawPredictedTrajectory();

      // 行星
      for (const p of (worldState.planets || [])) {
        ctx.fillStyle = "#222";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      // 所有飞船都画出来：我的亮，别人的暗
      (worldState.ships || []).forEach((ship) => {
        const isMine = (ship.id === myShipId);

        const colPlank = isMine ? "#888" : "#444";
        const colNode  = isMine ? "#0ff" : "#066";
        const colEng   = isMine ? "#f0f" : "#606";
        const colArrow = isMine ? "#0f0" : "#070";

        // planks
        (ship.planks || []).forEach((pl, pi) => {
          const isHoverDel = isMine && hoverDeleteTarget && hoverDeleteTarget.kind === "plank" && hoverDeleteTarget.index === pi;
          const isSelected = isMine && selectedTarget && selectedTarget.kind === "plank" && selectedTarget.index === pi;

          const pp = predictPose(pl, nowSec);
          ctx.save();
          ctx.translate(pp.x, pp.y);
          ctx.rotate(pp.angle);

          ctx.strokeStyle = isSelected ? "#f00" : (isHoverDel ? "#0f0" : colPlank);
          ctx.lineWidth = pl.radius * 2 / cameraZoom;

          ctx.beginPath();
          ctx.moveTo(-pl.length / 2, 0);
          ctx.lineTo(pl.length / 2, 0);
          ctx.stroke();

          ctx.restore();
        });

        // nodes
        (ship.nodes || []).forEach((n, ni) => {
          const isHoverBuild = isMine && hoverAnchor && hoverAnchor.kind === "node" && hoverAnchor.index === ni;
          const isHoverDel   = isMine && hoverDeleteTarget && hoverDeleteTarget.kind === "node" && hoverDeleteTarget.index === ni;
          const isSelected   = isMine && selectedTarget && selectedTarget.kind === "node" && selectedTarget.index === ni;

          const pn = predictPose(n, nowSec);
          ctx.beginPath();
          ctx.arc(pn.x, pn.y, n.radius, 0, Math.PI * 2);

          if (isSelected) ctx.fillStyle = "#f00";
          else if (isHoverDel || isHoverBuild) ctx.fillStyle = "#0f0";
          else ctx.fillStyle = colNode;

          ctx.fill();

          if (isHoverDel || isSelected) {
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.radius * 1.8, 0, Math.PI * 2);
            ctx.strokeStyle = isSelected ? "#f00" : "#0f0";
            ctx.lineWidth = 1.0 / cameraZoom;
            ctx.stroke();
          }
        });

        // engines
        (ship.engines || []).forEach((e, ei) => {
          const isHoverBuild = isMine && hoverAnchor && hoverAnchor.kind === "engine" && hoverAnchor.index === ei;
          const isHoverDel   = isMine && hoverDeleteTarget && hoverDeleteTarget.kind === "engine" && hoverDeleteTarget.index === ei;
          const isSelected   = isMine && selectedTarget && selectedTarget.kind === "engine" && selectedTarget.index === ei;

          const pe = predictPose(e, nowSec);
          ctx.save();
          ctx.translate(pe.x, pe.y);
          ctx.rotate(pe.angle);

          ctx.beginPath();
          ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 0.5 / cameraZoom;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(3 * e.radius, 0);
          ctx.stroke();

          if (ship.on_fire) {
            ctx.fillStyle = isMine ? "#ff8800" : "#663300";
            ctx.beginPath();
            ctx.moveTo(-3 * e.radius, 0);
            ctx.lineTo(-5 * e.radius, 1.5 * e.radius);
            ctx.lineTo(-5 * e.radius, -1.5 * e.radius);
            ctx.closePath();
            ctx.fill();
          }

          if (isHoverDel || isSelected) {
            ctx.beginPath();
            ctx.arc(0, 0, e.radius * 1.8, 0, Math.PI * 2);
            ctx.strokeStyle = isSelected ? "#f00" : "#0f0";
            ctx.lineWidth = 1.0 / cameraZoom;
            ctx.stroke();
          } else if (isHoverBuild) {
            ctx.beginPath();
            ctx.arc(0, 0, e.radius * 1.8, 0, Math.PI * 2);
            ctx.strokeStyle = "#ff0";
            ctx.lineWidth = 1.0 / cameraZoom;
            ctx.stroke();
          }

          ctx.restore();
        });

        // ship_angle arrow
        if (ship.nodes && ship.nodes.length > 0 && typeof ship.ship_angle === "number") {
          const core = ship.nodes[0];
          const ang = ship.ship_angle;
          const L = 30;

          const ex = core.x + Math.cos(ang) * L;
          const ey = core.y + Math.sin(ang) * L;

          ctx.strokeStyle = colArrow;
          ctx.lineWidth = 1.5 / cameraZoom;
          ctx.beginPath();
          ctx.moveTo(core.x, core.y);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          const headLen = 5;
          const leftAng = ang + Math.PI * 0.75;
          const rightAng = ang - Math.PI * 0.75;
          ctx.beginPath();
          ctx.moveTo(ex, ey);
          ctx.lineTo(ex + Math.cos(leftAng) * headLen, ey + Math.sin(leftAng) * headLen);
          ctx.moveTo(ex, ey);
          ctx.lineTo(ex + Math.cos(rightAng) * headLen, ey + Math.sin(rightAng) * headLen);
          ctx.stroke();
        }
      });

      // 建造模式：虚拟木板
      if (buildMode && isDraggingPlank && plankStartAnchor) {
        const s = getAnchorWorldPos(plankStartAnchor);
        if (s) {
          ctx.strokeStyle = "#0f0";
          ctx.setLineDash([5 / cameraZoom, 5 / cameraZoom]);
          ctx.lineWidth = 1.0 / cameraZoom;
          ctx.beginPath();
          ctx.moveTo(s.x, s.y);
          ctx.lineTo(dragWorldPos.x, dragWorldPos.y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      // 引擎建造预览
      if (isDraggingEngine && engineStartNode) {
        const ship = getMyShip();
        if (ship && ship.nodes) {
          const s = ship.nodes[engineStartNode.index];
          const dx = dragWorldPos.x - s.x;
          const dy = dragWorldPos.y - s.y;
          const len = Math.hypot(dx, dy);
          if (len > 1e-3) {
            const dirx = dx / len;
            const diry = dy / len;

            const ENGINE_MIN_R = 1.0;
            const ENGINE_MAX_R = 5.0;
            const ENGINE_LEN2R = 0.2;

            let radius = len * ENGINE_LEN2R;
            radius = Math.max(ENGINE_MIN_R, Math.min(ENGINE_MAX_R, radius));

            const offset = s.radius + radius + 2.0;
            const ex = s.x + dirx * offset;
            const ey = s.y + diry * offset;

            ctx.strokeStyle = "#ff0";
            ctx.setLineDash([5 / cameraZoom, 5 / cameraZoom]);
            ctx.lineWidth = 1.0 / cameraZoom;
            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(ex, ey);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.arc(ex, ey, radius, 0, Math.PI * 2);
            ctx.strokeStyle = "#ff0";
            ctx.lineWidth = 1.0 / cameraZoom;
            ctx.stroke();
          }
        }
      }
    }

    function drawHUD() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.font = "14px monospace";
      ctx.fillStyle = "#0f0";

      ctx.fillText(`uid: ${myUid ? myUid.slice(0, 8) + "..." : "(joining)" }  ship_id: ${myShipId ?? "-"}`, 10, H - 100);

      const ship = getMyShip();
      if (ship) {
        const deg = ship.ship_angle * 180 / Math.PI;
        ctx.fillText(`ship angle: ${deg.toFixed(1)}°`, 10, H - 82);
        ctx.fillText(`stabilize: ${ship.stabilize ? "ON" : "OFF"}`, 10, H - 64);
      }

      const cam = getCameraCenter();
      ctx.fillText(`camera: ${freeCamera ? "FREE(Tab)" : "FOLLOW"}  pos: (${cam.x.toFixed(1)}, ${cam.y.toFixed(1)})  zoom:${cameraZoom.toFixed(2)}`, 10, H - 46);

      const sel = selectedTarget ? (selectedTarget.kind + "#" + selectedTarget.index) : "none";
      ctx.fillText(`buildMode: ${buildMode ? "ON" : "OFF"}  selected: ${sel}`, 10, H - 28);

      if (predictedMeta) {
        ctx.fillText(`predict: ${predictedMeta.mode}  pts:${predictedPoints.length}  sec:${predictedMeta.seconds}s  dt:${predictedMeta.dt}`, 10, H - 10);
      } else {
        ctx.fillText(`predict: (waiting...)`, 10, H - 10);
      }
    }

    // ------------------------------
    // 与后端交互
    // ------------------------------
    async function fetchState() {
      try {
        const res = await fetch("/api/state");
        if (res.ok) {
          worldState = await res.json();
          updateCoreVelocityEstimate();
          lastStateArrivedAt = performance.now() / 1000;
        }
      } catch (e) {}
    }
    function predictPose(obj, nowSec) {
      const dt = nowSec - lastStateArrivedAt;
      const x = obj.x + (obj.vx ?? 0) * dt;
      const y = obj.y + (obj.vy ?? 0) * dt;
      const angle = obj.angle + (obj.ang_vel ?? 0) * dt;
      return { x, y, angle };
    }

    function sendControl() {
      if (!joined) return;
      fetch("/api/control", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          uid: myUid,
          fire: !!keys["Space"],
          left: !!keys["ArrowLeft"],
          right: !!keys["ArrowRight"],
          stabilize: !!keys["ShiftLeft"] || !!keys["ShiftRight"],
        }),
      }).catch(() => {});
    }

    // ------------------------------
    // 主循环
    // ------------------------------
    let lastFrameT = performance.now();
    function draw() {
      const now = performance.now();
      const dt = Math.min(0.05, (now - lastFrameT) / 1000);
      lastFrameT = now;

      updateFreeCamera(dt);
      updateMouseWorldAndHoverPerFrame();
      drawWorld();
      drawHUD();

      requestAnimationFrame(draw);
    }

    // 启动
    (async () => {
      await joinGame();
      setInterval(fetchState, 50);      // 20Hz
      setInterval(sendControl, 100);    // 10Hz
      setInterval(fetchPredict, 100);   // 4Hz
      requestAnimationFrame(draw);
    })();
  </script>
</body>
</html>
